# -*- coding: utf-8 -*-
"""Sude_birizkent

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vadZqWMPIrL-obiPCeiFgEu1KKpBYIK8
"""

import numpy as np
import matplotlib.pyplot as plt
import copy
import random
import math

# Mesafe Fonksiyonu (Öklid)
def calculate_distance(city1, city2):
    return np.linalg.norm(city1 - city2)

# Toplam Rota Maliyeti (Fitness Fonksiyonu) [cite: 113]
def calculate_route_cost(route, cities):
    total_dist = 0
    for i in range(len(route)):
        from_city = cities[route[i]]
        to_city = cities[route[(i + 1) % len(route)]] # Döngüsel, başlangıca dön
        total_dist += calculate_distance(from_city, to_city)
    return total_dist

# Shannon Entropisi Hesabı [cite: 131]
# Popülasyon çeşitliliğini ölçer. Düşükse "erken yakınsama" var demektir.
def calculate_entropy(population):
    pop_size = len(population)
    # Basitleştirilmiş entropi: Benzersiz rota sayısı üzerinden
    unique_routes = len(set(tuple(p) for p in population))
    p = unique_routes / pop_size
    if p == 0 or p == 1:
        return 0
    return -p * math.log2(p)

class DynamicEnvironment:
    def __init__(self, num_cities=52, area_size=100):
        self.num_cities = num_cities
        self.area_size = area_size
        # Başlangıçta rastgele şehirler (berlin52 vb. yerine rastgele simülasyon)
        self.cities = np.random.rand(num_cities, 2) * area_size
        self.initial_topology = copy.deepcopy(self.cities)

    # Senaryo 1: Drift (Sürüklenme) [cite: 119]
    # Koordinatlar rastgele bir vektör kadar kayar.
    def apply_drift(self, magnitude=1.0):
        drift_vector = np.random.randn(self.num_cities, 2) * magnitude
        self.cities += drift_vector
        # Alan dışına çıkmayı engelle (opsiyonel sınır)
        self.cities = np.clip(self.cities, 0, self.area_size)
        print(">> Ortam Değişimi: DRIFT uygulandı.")

    # Senaryo 2: Impulse (Topolojik Değişim) [cite: 121]
    # Şehirlerin %10'u silinir, yenileri eklenir.
    def apply_impulse(self, change_ratio=0.1):
        num_change = int(self.num_cities * change_ratio)
        # Rastgele indeksleri değiştir
        indices = np.random.choice(self.num_cities, num_change, replace=False)
        self.cities[indices] = np.random.rand(num_change, 2) * self.area_size
        print(f">> Ortam Değişimi: IMPULSE uygulandı ({num_change} şehir değişti).")

    def get_cities(self):
        return self.cities

class HybridGA:
    def __init__(self, env, pop_size=50, mutation_rate=0.05):
        self.env = env
        self.pop_size = pop_size
        self.mutation_rate = mutation_rate
        self.population = []
        self.memory = [] # Açık Hafıza (Explicit Memory)
        self.best_solution = None
        self.best_cost = float('inf')
        self.history_costs = []

        # Başlangıç Popülasyonu (Rastgele Permütasyonlar)
        for _ in range(pop_size):
            self.population.append(np.random.permutation(env.num_cities))

    # Inver-Over Operatörü [cite: 135-140]
    # Standart çaprazlama yerine kullanılır. Yerel aramayı güçlendirir.
    def inver_over_operator(self):
        new_population = []
        current_cities = self.env.get_cities()

        for i in range(self.pop_size):
            individual = copy.deepcopy(self.population[i])
            # 1. Rastgele bir şehir (c) seç [cite: 137]
            city_idx = np.random.randint(self.env.num_cities)
            current_city = individual[city_idx]

            # Döngü (Belirli bir iterasyon veya koşul sağlanana kadar)
            for _ in range(5): # Sonsuz döngüden kaçınmak için limitli
                # 2. Rastgele başka bir birey seç (S') [cite: 138]
                random_individual = self.population[np.random.randint(self.pop_size)]

                # Rastgele bireydeki komşuyu bul
                idx_in_rand = np.where(random_individual == current_city)[0][0]
                next_city_val = random_individual[(idx_in_rand + 1) % self.env.num_cities]

                # Eğer komşu aynıysa döngüden çık
                idx_in_curr = np.where(individual == current_city)[0][0]
                neighbor_in_curr = individual[(idx_in_curr + 1) % self.env.num_cities]

                if next_city_val == neighbor_in_curr:
                    break

                # 3. Ters Çevirme (Inversion) [cite: 139]
                # current_city ile next_city_val arasındaki segmenti ters çevir
                idx_next_in_curr = np.where(individual == next_city_val)[0][0]

                start, end = min(idx_in_curr + 1, idx_next_in_curr), max(idx_in_curr + 1, idx_next_in_curr)
                individual[start:end+1] = individual[start:end+1][::-1]

                current_city = next_city_val

            new_population.append(individual)

        self.population = new_population

    # Hafıza Yönetimi: Elitleri Kaydet [cite: 133]
    def update_memory(self):
        # Popülasyonu sırala
        ranked_pop = sorted(self.population, key=lambda x: calculate_route_cost(x, self.env.get_cities()))
        # En iyi %5'i hafızaya al (veya en iyisini)
        elite_count = max(1, int(self.pop_size * 0.05))
        self.memory = copy.deepcopy(ranked_pop[:elite_count])
        # Hafıza boyutu çok şişmesin, sadece son 20 elit kalsın
        if len(self.memory) > 20:
            self.memory = self.memory[:20]

    # Hafızadan Geri Çağırma (Retrieval) [cite: 134]
    # Ortam değiştiğinde çağrılır.
    def retrieve_memory(self):
        if not self.memory:
            return
        # Hafızadaki çözümleri mevcut popülasyonun en kötüleriyle değiştir
        # (Replacement Strategy)
        print(">> Hafıza Devreye Girdi: Elit bireyler popülasyona enjekte ediliyor.")
        current_pop_sorted = sorted(self.population, key=lambda x: calculate_route_cost(x, self.env.get_cities()), reverse=True)

        # En kötülerin yerine hafızadakileri koy
        for i in range(len(self.memory)):
            if i < len(self.population):
                self.population[i] = self.memory[i] # Basit değiştirme (worst replaced by memory)

    def evolve(self):
        # Fitness hesapla
        costs = [calculate_route_cost(p, self.env.get_cities()) for p in self.population]
        min_cost = min(costs)

        # En iyiyi güncelle
        if min_cost < self.best_cost:
            self.best_cost = min_cost
            self.best_solution = self.population[np.argmin(costs)]

        self.history_costs.append(min_cost)

        # Inver-Over uygula
        self.inver_over_operator()

# --- PARAMETRELER ---
NUM_CITIES = 50
POP_SIZE = 60
TOTAL_ITERATIONS = 300
CHANGE_INTERVAL = 30 # Her 50 iterasyonda ortam değişsin

# --- KURULUM ---
env = DynamicEnvironment(num_cities=NUM_CITIES)
ga = HybridGA(env, pop_size=POP_SIZE)

# --- SİMÜLASYON ---
results = []
change_points = []

print("Simülasyon Başlıyor...")

for t in range(1, TOTAL_ITERATIONS + 1):
    # 1. Ortam Değişimi Kontrolü
    if t % CHANGE_INTERVAL == 0:
        change_points.append(t)

        # Rastgele Drift veya Impulse seç
        if np.random.rand() > 0.5:
            env.apply_drift(magnitude=2.0)
        else:
            env.apply_impulse(change_ratio=0.1)

        # Değişim sonrası Hafızayı Tetikle [cite: 132]
        ga.retrieve_memory()

        # Best cost'u resetle (çünkü ortam değişti, eski best geçersiz olabilir)
        ga.best_cost = float('inf')

    # 2. Evrim Adımı (Inver-Over)
    ga.evolve()

    # 3. Hafıza Güncelleme (Her 10 adımda bir elitleri sakla) [cite: 133]
    if t % 10 == 0:
        ga.update_memory()

    # İstatistikleri kaydet
    current_best = ga.history_costs[-1]
    results.append(current_best)

    if t % 10 == 0:
        print(f"Iterasyon {t}: En İyi Maliyet = {current_best:.2f}")

# --- SONUÇLARI GÖRSELLEŞTİRME ---
plt.figure(figsize=(10, 6))
plt.plot(results, label="H-IGA En İyi Maliyet")
for cp in change_points:
    plt.axvline(x=cp, color='r', linestyle='--', label='Ortam Değişimi' if cp == change_points[0] else "")

plt.title("Dinamik TSP: H-IGA Performansı")
plt.xlabel("İterasyon")
plt.ylabel("Rota Maliyeti (Mesafe)")
plt.legend()
plt.grid(True)
plt.show()

# Son Rotayı Çizdir
best_route = ga.best_solution
cities = env.get_cities()
plt.figure(figsize=(6, 6))
x_coords = [cities[i][0] for i in best_route] + [cities[best_route[0]][0]]
y_coords = [cities[i][1] for i in best_route] + [cities[best_route[0]][1]]
plt.plot(x_coords, y_coords, 'g-o')
plt.title(f"Son Durumdaki En İyi Rota (Maliyet: {results[-1]:.2f})")
plt.show()

